extern crate bincode;

use std::net::*;
use hangmanstructs::*;
use std::sync::Arc;
use std::thread;

pub struct HangmanServer {
    socket: Arc<UdpSocket>,
    games: Vec<HangmanGame>,
    users: Vec<User>
}

impl HangmanServer {
    pub fn new() -> Result<HangmanServer, std::io::Error> {

        let socket = Arc::new(UdpSocket::bind("127.0.0.1:22565").unwrap());

        Ok(
            HangmanServer {
                socket,
                games: vec![],
                users: vec![]
            }
        )
    }

    pub fn listen(&self) {
        let mut event_buffer = [0; 65507]; // Lazy workaround
        let (event_size, source_address) = self.socket.recv_from(&mut event_buffer).expect("Failed to receive event!");
        let event_buffer = &mut event_buffer[0..event_size];

        let hangman_event: HangmanEvent = bincode::deserialize(&event_buffer).expect("Failed to deserialize event!");
        let thread_socket = Arc::clone(&self.socket);

        thread::spawn(move|| {
            self.handle_event(hangman_event, source_address, thread_socket);
        }); // dispatch the event to be handled
    }

    fn handle_event(&self, event: HangmanEvent, src: SocketAddr) -> Result<(), std::io::Error> {

        println!("{:?}" , event);
        println!("{:?}" , src);

        let buf = bincode::serialize(&HangmanEventResponse::Ok).expect("oof");
        self.socket.send_to(&buf, src).expect("oof");

        Ok(())
    }
}
